
总结：其实说白了，二叉树也就是4种遍历方式，外加列表存储一下树节点，重要的是弄懂树的递归是怎么一回事。

1、重建二叉树：题目给出的是： 先序+中序 或者是 层序+中序  解题思路：根据题中所给的序列分别构造相应的左右子树序列，然后左右分别递归，注意在递归出口节点创建树节点。

2、树的子结构：解题思路：先判断根节点值是否相等，然后再判断下面的结构是否相等，若根节点值不相等，则判断左子树和右子树是否与子结构相等          子函数（判断树中元素是否相等）：子结构为空返回True，树为空返回False，然后判断各个位置的值是否相等。（子函数返回True或者False的，一般递归出现在最后的return条件）

3、二叉树的镜像： 解题思路：交换左右子树的值 然后分别递归左右子树（也就是左右子树分别交换）

4、判断是否是对称的二叉树（也就是镜像二叉树）： 解题思路：比较左右子树  子函数：先判断左右子树均为空返回True 有一个为空返回False ，然后再比较根节点的值，若相等接着递归比较左==右，右==左

5、从上往下打印二叉树： 解题思路：先把数放入列表中，方便索引。 当列表不为空的时候，若根节点存在左节点则把左节点放入树列表的后面，同理右节点也是。然后保存根节点的值，同时pop出根节点。

6、从上往下按行打印二叉树：解题思路：与上面的不同就是要建立一个临时列表list1保存根节点的值，还有建立一个临时列表list2保存子节点的值，循环完根节点列表以后，用临时列表list1保存根节点的值同时把list2中的子节点的值赋值给根节点列表，再次循环。（其实这就是二叉树的层序遍历）

15、之字形打印二叉树： 解题思路：利用一个标志变量flag来标记从左往右还是从右往走，然后就是利用栈和flag=1的时候反向储存节点值，实现。

7、判断数组是否是二叉搜索树的后序遍历序列：解题思路：后续遍历的特点就是最后一个节点是根节点。然后二叉搜索树的特点就是左子树小于根节点的值，右子树大于根节点的值。所以我们的解题思路就是先分割左右子树，然后判断左右子树是否满足二叉搜索树的条件，然后分别递归左右子树。

8、二叉树中和为某一值(k)的路径（路径总和二）：  解题思路：先创建一个类变量sum用于存放求和值。再创建一个列表self.a存放路径中的数值。若sum==k且左右子树均为空，self.b.append(self.a[:])，若sum小于k，递归左右子树，否则（大于k）sum -=self.a[-1],self.a.pop()  

16、路径总和：因为是返回True或False所以return 递归。

9、二叉搜索树转化为双向链表： 解题思路：先递归转化左子树，在把左子树的最右边一个节点链接到根节点上（双向链接），同理右子树，然后从根节点向前寻找头结点，返回头结点的地址

24、二叉树展开为链表：先找到左子树的最右边节点，然后将右节点挂在左子树的最右边节点上，最后再把整个左子树挂在根节点的右边。然后后序遍历二叉树。

10、二叉树的最大深度： 解题思路：（1）后序遍历，返回左右子树的最大值+1  （2）按层向下检索，与2,5相似

23、二叉树的最小深度：与上相似，区别在于添加一个判断左节点或右节点为空，然后返回left+right+1.

11、平衡二叉树： 解题思路：后序遍历，判断左右子树长度差。（这里有一个编程小技巧，建立一个类变量，用于子函数在递归过程中返回True或False。满足条件立即保存状态。）

12、二叉搜索树的第K个节点： 解题思路：中序遍历

13、二叉树的下一个节点： 解题思路：两条路径，（1）若此节点的右子树存在，则递推返回右子树的最左节点。（2）若此节点的下一个节点是是根节点，若根节点的左节点==此节点，则返回根节点，否则继续向上递推根节点。

14、序列化二叉树： 解题思路：序列化：若空==‘#’然后中序遍历  反序列化：建立一个标志位用来索引序列列表。若非空，赋值root，递归root.left 和 root.right（其实序列化就是二叉树的前序遍历，反序列化就是前序重建二叉树）

17、二叉树的中序遍历、后序遍历：迭代法遍历二叉树，用颜色标记走过的节点位，然后用栈来实现遍历。

18、验证二叉搜索树：根据二叉搜索树的性质给出递归的出口条件，然后递归验证左右子树（注意递归左右子树传入的值，左子树的left=left，right=root.val，右子树的left=root.val，right=right）

19、恢复二叉搜索树：跟上面一样，多了一个交换节点值的步骤。

20、相同的树：因为是返回True或False所以return 递归。

21、将有序数组转为二叉搜索树：实际上就是中序遍历转二叉搜索树，因为不是唯一的，所以取中间元素作为根节点，左边就是左子树，右边就是右子树。

22、合法的二叉搜索树：递归：上面判断条件return进行递归    中序遍历：中序遍历二叉搜索树天然有序！！

25、节点与其祖先的最大差值：子函数寻找最大最小值

26、累加树：因为是二叉搜索树，所以中序遍历的反向就是从大到小排序（右中左），然后累加节点值更新下一节点值。

27、填充每个节点的下一个右节点指针：构造条件（左节点存在，则左节点的next指向右节点，next节点存在，则有节点的next指向next的左节点）+递归

28、填充每个节点的下一个右节点指针2：子函数寻找next节点的最左节点，主函数判断连接情况以后再递归（先右后左，因为有右边才有左边）

29、求根到叶子结点的数字和：简单条件加递归，注意找回递归根节点的值。

30、二叉搜索树的迭代器：迭代搜索树

31、二叉树的右视图：层序遍历

32、二叉搜索树中第k小元素：迭代法：利用栈保存树，中序遍历

33、二叉树的最近公共祖先：遍历查找，左没有就在右，右没有就在左，都有就在root

34、从先序遍历还原二叉树：用字典保存二叉树节点。遍历先序数组，保存字符和相应的深度，然后传入子函数建立树

35、字典树：用字典保存树儿子节点，字典嵌套。

